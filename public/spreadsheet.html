<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campaign Mapper - Spreadsheet View</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
        }
        .table-container {
            max-height: 600px;
            overflow-y: auto;
        }
        .table th {
            position: sticky;
            top: 0;
            background-color: #f8f9fa;
            z-index: 10;
        }
        .table-hover tbody tr:hover {
            background-color: rgba(0, 123, 255, 0.05);
        }
        .form-control:focus {
            border-color: #80bdff;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }
        #sqlOutput {
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
        }
        .selected {
            background-color: #e9ecef !important;
        }
        .btn-toolbar {
            margin-bottom: 15px;
        }
        .btn-group {
            margin-right: 10px;
        }
        .filter-container {
            margin-bottom: 15px;
        }

        /* Drag and Drop Styles */
        .sortable-ghost {
            opacity: 0.4;
            background-color: #e9ecef;
        }

        .drag-handle {
            cursor: move;
            color: #6c757d;
        }

        .drag-handle:hover {
            color: #343a40;
        }

        /* Order Manager Styles */
        #networkOrderList, #nameOrderList {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
        }

        #networkOrderList .list-group-item, #nameOrderList .list-group-item {
            padding: 0.5rem 1rem;
            border-left: none;
            border-right: none;
            border-radius: 0;
        }

        #networkOrderList .list-group-item:first-child, #nameOrderList .list-group-item:first-child {
            border-top: none;
        }

        #networkOrderList .list-group-item:last-child, #nameOrderList .list-group-item:last-child {
            border-bottom: none;
        }

        /* Unmapped row highlighting */
        .unmapped {
            background-color: #fff3cd;
        }

        /* Copy buttons */
        .copy-to-pretty-btn {
            font-size: 0.7rem;
            padding: 0.1rem 0.3rem;
        }

        /* Rule list styles */
        #rulesList .list-group-item {
            padding: 0.5rem 1rem;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <h1 class="mb-3">Campaign Mapper - Spreadsheet View</h1>
        <p class="lead">Upload your CSV data, map networks and campaigns to pretty names, and generate SQL queries.</p>

        <!-- CSV Upload Section -->
        <div class="card mb-4">
            <div class="card-header">
                <h2 class="h5 mb-0">Upload Campaign Data CSV</h2>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <input type="file" id="csvFile" accept=".csv" class="form-control">
                </div>
                <div class="mb-3">
                    <label class="form-label">Data Format:</label>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="radio" name="dataFormat" id="formatMatomo" value="matomo" checked>
                        <label class="form-check-label" for="formatMatomo">Matomo</label>
                    </div>
                    <div class="form-check form-check-inline">
                        <input class="form-check-input" type="radio" name="dataFormat" id="formatRedTrack" value="redtrack">
                        <label class="form-check-label" for="formatRedTrack">RedTrack</label>
                    </div>
                </div>
                <div id="uploadStatus"></div>
                <button id="loadSampleBtn" class="btn btn-outline-secondary">Load Sample Data</button>
                <button id="copyFromOriginalBtn" class="btn btn-outline-secondary ms-2">Copy from Original CSV</button>
            </div>
        </div>

        <!-- Data Mapping Section (hidden until CSV is loaded) -->
        <div id="mappingSection" style="display: none;">
            <!-- Toolbar -->
            <div class="btn-toolbar">
                <div class="btn-group">
                    <button id="capitalizeNetworksBtn" class="btn btn-outline-primary">Capitalize Networks</button>
                    <button id="capitalizeCampaignsBtn" class="btn btn-outline-primary">Capitalize Campaigns</button>
                </div>
                <div class="btn-group">
                    <button id="addNetworkPrefixBtn" class="btn btn-outline-primary">Add Network Prefix</button>
                    <button id="clearAllBtn" class="btn btn-outline-danger">Clear All</button>
                </div>
                <div class="btn-group ms-auto">
                    <button id="generateSqlBtn" class="btn btn-primary">Generate SQL</button>
                </div>
            </div>

            <!-- Filter Controls -->
            <div class="filter-container row">
                <div class="col-md-3">
                    <input type="text" id="filterInput" class="form-control" placeholder="Filter by any column...">
                </div>
                <div class="col-md-3">
                    <select id="sourceTypeFilter" class="form-select">
                        <option value="">All Source Types</option>
                        <option value="Campaign">Campaign</option>
                        <option value="Search Engine">Search Engine</option>
                        <option value="Social Network">Social Network</option>
                        <option value="Website">Website</option>
                        <option value="Direct">Direct</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <select id="networkFilter" class="form-select">
                        <option value="">All Networks</option>
                    </select>
                </div>
                <div class="col-md-3">
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="showMappedOnly">
                        <label class="form-check-label" for="showMappedOnly">Show Mapped Only</label>
                    </div>
                </div>
            </div>

            <!-- Spreadsheet Table -->
            <div class="table-container">
                <table class="table table-bordered table-hover" id="campaignTable">
                    <thead>
                        <tr>
                            <th width="50">ID</th>
                            <th>Source Type</th>
                            <th>Original Name</th>
                            <th>Original Network</th>
                            <th>Pretty Network</th>
                            <th>Pretty Name</th>
                            <th width="100">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="campaignTableBody"></tbody>
                </table>
            </div>

            <!-- Auto-Mapping Rules -->
            <div class="card mt-4 mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h2 class="h5 mb-0">Auto-Mapping Rules</h2>
                    <div>
                        <button id="applyRulesBtn" class="btn btn-primary">Apply Rules</button>
                        <button id="saveRulesBtn" class="btn btn-outline-secondary ms-2">Save Rules</button>
                        <button id="loadRulesBtn" class="btn btn-outline-secondary ms-2">Load Rules</button>
                    </div>
                </div>
                <div class="card-body">
                    <div class="row mb-3">
                        <div class="col-md-12">
                            <p>Automatically map entries based on predefined rules. Rules are applied in order.</p>
                            <div class="form-check form-switch mb-3">
                                <input class="form-check-input" type="checkbox" id="autoApplyRules" checked>
                                <label class="form-check-label" for="autoApplyRules">Auto-apply rules when loading data</label>
                            </div>
                            <div class="list-group" id="rulesList">
                                <!-- Rules will be added here dynamically -->
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-12">
                            <h3 class="h6 mt-3">Save/Load Mappings</h3>
                            <div class="btn-group">
                                <button id="saveMappingsBtn" class="btn btn-outline-primary">Save Mappings</button>
                                <button id="loadMappingsBtn" class="btn btn-outline-primary">Load Mappings</button>
                                <input type="file" id="loadMappingsFile" accept=".json" style="display: none;">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Order Manager -->
            <div class="card mt-4 mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h2 class="h5 mb-0">Order Manager</h2>
                    <div>
                        <button id="updateOrderBtn" class="btn btn-primary">Update Order</button>
                        <button id="resetOrderBtn" class="btn btn-outline-secondary ms-2">Reset Order</button>
                    </div>
                </div>
                <div class="card-body">
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <h3 class="h6">Networks</h3>
                            <div class="list-group" id="networkOrderList">
                                <!-- Networks will be added here dynamically -->
                            </div>
                        </div>
                        <div class="col-md-6">
                            <h3 class="h6">Names in Selected Network</h3>
                            <select id="orderNetworkSelect" class="form-select mb-2">
                                <option value="">Select a network to order its names</option>
                            </select>
                            <div class="list-group" id="nameOrderList">
                                <!-- Names will be added here dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- SQL Generator -->
            <div class="card mt-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h2 class="h5 mb-0">SQL Query</h2>
                    <button id="copySqlBtn" class="btn btn-outline-secondary">Copy to Clipboard</button>
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        <label for="tableNameInput" class="form-label">Table Name:</label>
                        <input type="text" id="tableNameInput" class="form-control" value="matomotransfers.matomo_export.log_visit" placeholder="Enter table name">
                        <small class="form-text text-muted">Default tables: Matomo = matomotransfers.matomo_export.log_visit, RedTrack = matomotransfers.rt_streamer.log_visit</small>
                    </div>
                    <textarea id="sqlOutput" class="form-control" rows="10" readonly></textarea>
                </div>
            </div>
        </div>
    </div>

    <!-- JavaScript Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

    <!-- Rule Engine -->
    <script src="js/rule-engine.js"></script>

    <!-- Application Script -->
    <script>
        // Application State
        const appState = {
            csvData: [],
            mappings: [],
            selectedCell: null,
            copiedValue: null,
            dataFormat: 'matomo', // Default to Matomo format
            filters: {
                text: '',
                sourceType: '',
                network: '',
                mappedOnly: false
            },
            ordering: {
                networks: [],
                namesByNetwork: {}
            },
            autoApplyRules: true // Default to auto-apply rules
        };

        // DOM Elements
        document.addEventListener('DOMContentLoaded', function() {
            const elements = {
                csvFile: document.getElementById('csvFile'),
                formatMatomo: document.getElementById('formatMatomo'),
                formatRedTrack: document.getElementById('formatRedTrack'),
                loadSampleBtn: document.getElementById('loadSampleBtn'),
                copyFromOriginalBtn: document.getElementById('copyFromOriginalBtn'),
                uploadStatus: document.getElementById('uploadStatus'),
                mappingSection: document.getElementById('mappingSection'),
                campaignTableBody: document.getElementById('campaignTableBody'),
                capitalizeNetworksBtn: document.getElementById('capitalizeNetworksBtn'),
                capitalizeCampaignsBtn: document.getElementById('capitalizeCampaignsBtn'),
                addNetworkPrefixBtn: document.getElementById('addNetworkPrefixBtn'),
                clearAllBtn: document.getElementById('clearAllBtn'),
                generateSqlBtn: document.getElementById('generateSqlBtn'),
                sqlOutput: document.getElementById('sqlOutput'),
                copySqlBtn: document.getElementById('copySqlBtn'),
                tableNameInput: document.getElementById('tableNameInput'),
                filterInput: document.getElementById('filterInput'),
                sourceTypeFilter: document.getElementById('sourceTypeFilter'),
                networkFilter: document.getElementById('networkFilter'),
                showMappedOnly: document.getElementById('showMappedOnly'),
                networkOrderList: document.getElementById('networkOrderList'),
                nameOrderList: document.getElementById('nameOrderList'),
                orderNetworkSelect: document.getElementById('orderNetworkSelect'),
                updateOrderBtn: document.getElementById('updateOrderBtn'),
                resetOrderBtn: document.getElementById('resetOrderBtn'),
                // New rule engine elements
                applyRulesBtn: document.getElementById('applyRulesBtn'),
                saveRulesBtn: document.getElementById('saveRulesBtn'),
                loadRulesBtn: document.getElementById('loadRulesBtn'),
                autoApplyRules: document.getElementById('autoApplyRules'),
                rulesList: document.getElementById('rulesList'),
                saveMappingsBtn: document.getElementById('saveMappingsBtn'),
                loadMappingsBtn: document.getElementById('loadMappingsBtn'),
                loadMappingsFile: document.getElementById('loadMappingsFile')
            };

            // Set up event listeners
            elements.csvFile.addEventListener('change', function(event) {
                handleFileUpload(event, elements);
            });

            elements.formatMatomo.addEventListener('change', function() {
                if (this.checked) {
                    appState.dataFormat = 'matomo';
                    console.log('Data format set to Matomo');
                    // Update default table name
                    elements.tableNameInput.value = 'matomotransfers.matomo_export.log_visit';
                    // If data is already loaded, reprocess it
                    if (appState.csvData.length > 0) {
                        initializeMappings(elements);
                    }
                }
            });

            elements.formatRedTrack.addEventListener('change', function() {
                if (this.checked) {
                    appState.dataFormat = 'redtrack';
                    console.log('Data format set to RedTrack');
                    // Update default table name
                    elements.tableNameInput.value = 'matomotransfers.rt_streamer.log_visit';
                    // If data is already loaded, reprocess it
                    if (appState.csvData.length > 0) {
                        initializeMappings(elements);
                    }
                }
            });

            elements.loadSampleBtn.addEventListener('click', function() {
                loadSampleData(elements);
            });

            elements.copyFromOriginalBtn.addEventListener('click', function() {
                copyFromOriginal(elements);
            });

            elements.capitalizeNetworksBtn.addEventListener('click', function() {
                capitalizeNetworks(elements);
            });

            elements.capitalizeCampaignsBtn.addEventListener('click', function() {
                capitalizeCampaigns(elements);
            });

            elements.addNetworkPrefixBtn.addEventListener('click', function() {
                addNetworkPrefix(elements);
            });

            elements.clearAllBtn.addEventListener('click', function() {
                clearAllMappings(elements);
            });

            elements.generateSqlBtn.addEventListener('click', function() {
                generateSql(elements);
            });

            elements.copySqlBtn.addEventListener('click', function() {
                copySqlToClipboard(elements);
            });

            elements.tableNameInput.addEventListener('change', function() {
                generateSql(elements);
            });

            elements.filterInput.addEventListener('input', function() {
                appState.filters.text = this.value.toLowerCase();
                applyFilters(elements);
            });

            elements.sourceTypeFilter.addEventListener('change', function() {
                appState.filters.sourceType = this.value;
                applyFilters(elements);
            });

            elements.networkFilter.addEventListener('change', function() {
                appState.filters.network = this.value.toLowerCase();
                applyFilters(elements);
            });

            elements.showMappedOnly.addEventListener('change', function() {
                appState.filters.mappedOnly = this.checked;
                applyFilters(elements);
            });

            elements.orderNetworkSelect.addEventListener('change', function() {
                renderNameOrderList(elements);
            });

            elements.updateOrderBtn.addEventListener('click', function() {
                updateOrderFromUI(elements);
                generateSql(elements);
            });

            elements.resetOrderBtn.addEventListener('click', function() {
                resetOrder(elements);
                renderOrderLists(elements);
            });

            // Rule engine event listeners
            elements.applyRulesBtn.addEventListener('click', function() {
                applyRulesToMappings(elements);
            });

            elements.saveRulesBtn.addEventListener('click', function() {
                saveRulesToFile();
            });

            elements.loadRulesBtn.addEventListener('click', function() {
                // Trigger file input click
                elements.loadMappingsFile.click();
            });

            elements.autoApplyRules.addEventListener('change', function() {
                appState.autoApplyRules = this.checked;
            });

            elements.saveMappingsBtn.addEventListener('click', function() {
                saveMappingsToFile();
            });

            elements.loadMappingsBtn.addEventListener('click', function() {
                elements.loadMappingsFile.click();
            });

            elements.loadMappingsFile.addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (file) {
                    loadMappingsFromFile(file, elements);
                }
            });

            // Render rules list
            renderRulesList(elements);

            // Add keyboard shortcuts for copy/paste
            document.addEventListener('keydown', function(e) {
                // Ctrl+C or Cmd+C
                if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                    if (appState.selectedCell) {
                        const value = appState.selectedCell.textContent || appState.selectedCell.value;
                        if (value) {
                            appState.copiedValue = value;
                            navigator.clipboard.writeText(value);
                        }
                    }
                }
                // Ctrl+V or Cmd+V
                else if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                    if (appState.selectedCell && appState.selectedCell.tagName === 'INPUT') {
                        navigator.clipboard.readText().then(text => {
                            appState.selectedCell.value = text;
                            // Trigger change event
                            const event = new Event('change');
                            appState.selectedCell.dispatchEvent(event);
                        });
                    }
                }
            });
        });

        // Handle CSV file upload
        function handleFileUpload(event, elements) {
            const file = event.target.files[0];
            if (!file) return;

            elements.uploadStatus.innerHTML = '<div class="alert alert-info">Processing file...</div>';

            // Auto-detect format based on filename
            const filename = file.name.toLowerCase();
            if (filename.includes('redtrack')) {
                // Set format to RedTrack
                appState.dataFormat = 'redtrack';
                elements.formatRedTrack.checked = true;
                elements.formatMatomo.checked = false;
                elements.tableNameInput.value = 'matomotransfers.rt_streamer.log_visit';
                console.log('Format auto-detected as RedTrack based on filename');
            } else if (filename.includes('matomo')) {
                // Set format to Matomo
                appState.dataFormat = 'matomo';
                elements.formatMatomo.checked = true;
                elements.formatRedTrack.checked = false;
                elements.tableNameInput.value = 'matomotransfers.matomo_export.log_visit';
                console.log('Format auto-detected as Matomo based on filename');
            }

            // First, try to detect the delimiter by reading the first few lines
            const reader = new FileReader();
            reader.onload = function(e) {
                const sample = e.target.result.slice(0, 2000); // Get first 2000 chars for detection

                // Try to detect the delimiter
                let delimiter = ','; // Default delimiter

                // Check if the file might be using tabs
                if (sample.includes('\t')) {
                    delimiter = '\t';
                    console.log('Detected tab delimiter');
                }

                // Check for semicolons (common in European CSV)
                else if (sample.includes(';') && !sample.includes(',')) {
                    delimiter = ';';
                    console.log('Detected semicolon delimiter');
                }

                // Now parse with the detected delimiter
                Papa.parse(file, {
                    header: true,
                    delimiter: delimiter,
                    skipEmptyLines: true,
                    error: function(error) {
                        console.error('Parsing error:', error);
                        elements.uploadStatus.innerHTML = `<div class="alert alert-danger">Error parsing CSV: ${error.message}</div>`;
                    },
                    complete: function(results) {
                        if (results.errors.length > 0) {
                            console.error('Parse errors:', results.errors);
                            elements.uploadStatus.innerHTML = `<div class="alert alert-danger">Error parsing CSV: ${results.errors[0].message}. Tried using delimiter: "${delimiter}"</div>`;
                            return;
                        }

                        // Process the data
                        appState.csvData = results.data;

                    // Auto-detect format based on headers
                    if (results.meta.fields) {
                        const headers = results.meta.fields;

                        console.log('CSV Headers:', headers);

                        // Check for RedTrack format with click_id field (new format)
                        if (headers.includes('click_id')) {
                            appState.dataFormat = 'redtrack_new';
                            elements.formatRedTrack.checked = true;
                            elements.formatMatomo.checked = false;
                            elements.tableNameInput.value = 'matomotransfers.rt_streamer.log_visit';
                            console.log('Format auto-detected as new RedTrack format based on headers');
                        }
                        // Check for RedTrack format with deduced_source, campaign_name, utm_source
                        else if (headers.includes('deduced_source') && headers.includes('campaign_name') &&
                                headers.includes('utm_source')) {
                            appState.dataFormat = 'redtrack';
                            elements.formatRedTrack.checked = true;
                            elements.formatMatomo.checked = false;
                            elements.tableNameInput.value = 'matomotransfers.rt_streamer.log_visit';
                            console.log('Format auto-detected as RedTrack format based on headers');
                        }
                        // Check for Matomo format
                        else if (headers.includes('deduced_source') && headers.includes('campaign_name') &&
                                headers.includes('campaign_source')) {
                            appState.dataFormat = 'matomo';
                            elements.formatMatomo.checked = true;
                            elements.formatRedTrack.checked = false;
                            elements.tableNameInput.value = 'matomotransfers.matomo_export.log_visit';
                            console.log('Format auto-detected as Matomo format based on headers');
                        }
                    }

                    elements.uploadStatus.innerHTML = `<div class="alert alert-success">File loaded successfully! ${appState.csvData.length} rows found. Format detected: ${appState.dataFormat} (Delimiter: ${delimiter})</div>`;

                    // Initialize mappings
                    initializeMappings(elements);

                    // Show mapping section
                    elements.mappingSection.style.display = 'block';
                    }
                });
            };

            // Start the process by reading the file
            reader.readAsText(file);
        }

        // Load sample data
        function loadSampleData(elements) {
            elements.uploadStatus.innerHTML = '<div class="alert alert-info">Loading sample data...</div>';

            // Load sample data from the sample-data.csv file
            fetch('sample-data.csv')
                .then(response => response.text())
                .then(csvText => {
                    // Try to detect the delimiter from the sample data
                    const sample = csvText.slice(0, 2000); // Get first 2000 chars for detection
                    let delimiter = ','; // Default delimiter

                    // Check if the file might be using tabs
                    if (sample.includes('\t')) {
                        delimiter = '\t';
                        console.log('Detected tab delimiter in sample data');
                    }
                    // Check for semicolons (common in European CSV)
                    else if (sample.includes(';') && !sample.includes(',')) {
                        delimiter = ';';
                        console.log('Detected semicolon delimiter in sample data');
                    }

                    Papa.parse(csvText, {
                        header: true,
                        delimiter: delimiter,
                        skipEmptyLines: true,
                        complete: function(results) {
                            if (results.errors.length > 0) {
                                console.error('Parse errors:', results.errors);
                                elements.uploadStatus.innerHTML = `<div class="alert alert-danger">Error parsing CSV: ${results.errors[0].message}. Tried using delimiter: "${delimiter}"</div>`;
                                return;
                            }

                            // Process the data
                            appState.csvData = results.data;
                            elements.uploadStatus.innerHTML = `<div class="alert alert-success">Sample data loaded successfully! ${appState.csvData.length} rows found. (Delimiter: ${delimiter})</div>`;

                            // Initialize mappings
                            initializeMappings(elements);

                            // Show mapping section
                            elements.mappingSection.style.display = 'block';
                        }
                    });
                })
                .catch(error => {
                    elements.uploadStatus.innerHTML = `<div class="alert alert-danger">Error loading sample data: ${error.message}</div>`;
                });
        }

        // Initialize mappings
        function initializeMappings(elements) {
            // Create a unique list of entries based on source type
            const uniqueEntries = new Map();

            if (appState.dataFormat === 'matomo') {
                // Process Matomo format
                appState.csvData.forEach((row, index) => {
                    let key;
                    let entry;

                    // Handle different source types differently
                    if (row.deduced_source === 'Campaign') {
                        // For campaigns, use campaign_source + campaign_name as key
                        key = `Campaign-${row.campaign_source || ''}-${row.campaign_name || ''}`;
                        entry = {
                            id: index,
                            source: row.deduced_source,
                            originalName: row.campaign_name || '',
                            originalNetwork: row.campaign_source || '',
                            prettyNetwork: row.campaign_source || '',
                            prettyName: row.campaign_name || '',
                            refererName: row.referer_name || ''
                        };
                    } else {
                        // For other sources (Search Engine, Social Network, Website), use referer_name as key
                        key = `${row.deduced_source || ''}-${row.referer_name || ''}`;
                        entry = {
                            id: index,
                            source: row.deduced_source || '',
                            originalName: row.referer_name || '',
                            originalNetwork: row.deduced_source || '',  // Use source type as network for non-campaigns
                            prettyNetwork: row.deduced_source || '',
                            prettyName: row.referer_name || '',
                            refererName: row.referer_name || ''
                        };
                    }

                    if (!uniqueEntries.has(key) && key !== '-') {
                        uniqueEntries.set(key, entry);
                    }
                });
            } else if (appState.dataFormat === 'redtrack') {
                // Process RedTrack format
                appState.csvData.forEach((row, index) => {
                    let key;
                    let entry;

                    // For RedTrack, use deduced_source + campaign_name as key
                    key = `${row.deduced_source || ''}-${row.campaign_name || ''}-${row.device_type || ''}`;

                    // Determine the source and network based on the data
                    const source = row.deduced_source || '';
                    const campaignName = row.campaign_name || '';
                    const utmCampaign = row.utm_campaign || '';
                    const utmSource = row.utm_source || '';
                    const deviceType = row.device_type || '';

                    entry = {
                        id: index,
                        source: source,
                        originalName: campaignName,
                        originalNetwork: utmSource || source, // Use utm_source if available, otherwise use deduced_source
                        prettyNetwork: utmSource || source,
                        prettyName: campaignName,
                        utmCampaign: utmCampaign,
                        deviceType: deviceType
                    };

                    if (!uniqueEntries.has(key) && key !== '-') {
                        uniqueEntries.set(key, entry);
                    }
                });
            } else if (appState.dataFormat === 'redtrack_new') {
                // Process new RedTrack format
                appState.csvData.forEach((row, index) => {
                    let key;
                    let entry;

                    // For new RedTrack format, extract all possible fields
                    // Log the first row to see what fields are available
                    if (index === 0) {
                        console.log('RedTrack New Format Sample Row:', row);
                    }

                    // Extract fields with fallbacks
                    const deviceType = row.device || row.device_type || '';
                    const campaignName = row.campaign || '';
                    const source = row.source || '';
                    const network = row.network || '';
                    const rtSource = row.rt_source || '';
                    const rtCampaign = row.rt_campaign || '';
                    const rtMedium = row.rt_medium || '';

                    // Create a unique key - try to make it as unique as possible
                    key = `${source || ''}-${campaignName || ''}-${deviceType || ''}-${rtCampaign || ''}`;

                    // Determine the best values for mapping
                    const bestSource = source || rtSource || '';
                    const bestCampaign = campaignName || rtCampaign || '';
                    const bestNetwork = network || rtSource || source || '';

                    entry = {
                        id: index,
                        source: bestSource,
                        originalName: bestCampaign,
                        originalNetwork: bestNetwork,
                        prettyNetwork: bestNetwork,
                        prettyName: bestCampaign,
                        deviceType: deviceType,
                        rtSource: rtSource,
                        rtCampaign: rtCampaign,
                        rtMedium: rtMedium,
                        clickId: row.click_id || ''
                    };

                    if (!uniqueEntries.has(key) && key !== '-') {
                        uniqueEntries.set(key, entry);
                    }
                });
            }

            appState.mappings = Array.from(uniqueEntries.values());

            // Apply rules if auto-apply is enabled
            if (appState.autoApplyRules) {
                applyRulesToMappings(elements);
            }

            // Initialize ordering
            initializeOrdering();

            // Populate network filter dropdown
            populateNetworkFilter(elements);

            // Render order lists
            renderOrderLists(elements);

            // Render the table
            renderTable(elements);
        }

        // Populate network filter dropdown
        function populateNetworkFilter(elements) {
            const networks = new Set();

            appState.mappings.forEach(mapping => {
                if (mapping.network) {
                    networks.add(mapping.network.toLowerCase());
                }
            });

            // Clear existing options except the first one
            while (elements.networkFilter.options.length > 1) {
                elements.networkFilter.remove(1);
            }

            // Add new options
            Array.from(networks).sort().forEach(network => {
                const option = document.createElement('option');
                option.value = network;
                option.textContent = network;
                elements.networkFilter.appendChild(option);
            });
        }

        // Render the table
        function renderTable(elements) {
            elements.campaignTableBody.innerHTML = '';

            // Update table headers based on data format
            const tableHeaders = document.querySelector('#campaignTable thead tr');
            if (tableHeaders) {
                if (appState.dataFormat === 'redtrack' || appState.dataFormat === 'redtrack_new') {
                    // Add device type column for RedTrack format
                    if (!document.getElementById('deviceTypeHeader')) {
                        tableHeaders.innerHTML = `
                            <th width="50">ID</th>
                            <th>Source Type</th>
                            <th>Original Name</th>
                            <th>Original Network</th>
                            <th id="deviceTypeHeader">Device Type</th>
                            <th>Pretty Network</th>
                            <th>Pretty Name</th>
                            <th width="100">Actions</th>
                        `;
                    }
                } else {
                    // Standard Matomo format
                    tableHeaders.innerHTML = `
                        <th width="50">ID</th>
                        <th>Source Type</th>
                        <th>Original Name</th>
                        <th>Original Network</th>
                        <th>Pretty Network</th>
                        <th>Pretty Name</th>
                        <th width="100">Actions</th>
                    `;
                }
            }

            appState.mappings.forEach((mapping, index) => {
                if (!shouldShowMapping(mapping)) return;

                const row = document.createElement('tr');
                row.dataset.id = mapping.id;

                // Add unmapped class if either pretty network or pretty name is empty
                if (!mapping.prettyNetwork || !mapping.prettyName) {
                    row.classList.add('unmapped');
                }

                if (appState.dataFormat === 'redtrack' || appState.dataFormat === 'redtrack_new') {
                    // RedTrack format with device type
                    row.innerHTML = `
                        <td>${mapping.id + 1}</td>
                        <td>${mapping.source}</td>
                        <td>${mapping.originalName}
                            <button class="btn btn-sm btn-outline-secondary copy-to-pretty-btn"
                                    data-id="${mapping.id}" data-field="originalName" data-target="prettyName">
                                ↓
                            </button>
                        </td>
                        <td>${mapping.originalNetwork}
                            <button class="btn btn-sm btn-outline-secondary copy-to-pretty-btn"
                                    data-id="${mapping.id}" data-field="originalNetwork" data-target="prettyNetwork">
                                ↓
                            </button>
                        </td>
                        <td>${mapping.deviceType || ''}</td>
                        <td>
                            <input type="text" class="form-control network-input" value="${mapping.prettyNetwork}"
                                   data-id="${mapping.id}" data-field="prettyNetwork">
                        </td>
                        <td>
                            <input type="text" class="form-control name-input" value="${mapping.prettyName}"
                                   data-id="${mapping.id}" data-field="prettyName">
                        </td>
                        <td class="text-center">
                            <button class="btn btn-sm btn-outline-secondary copy-network-btn" data-id="${mapping.id}">
                                Copy Net
                            </button>
                            <button class="btn btn-sm btn-outline-secondary copy-campaign-btn" data-id="${mapping.id}">
                                Copy Camp
                            </button>
                        </td>
                    `;
                } else {
                    // Standard Matomo format
                    row.innerHTML = `
                        <td>${mapping.id + 1}</td>
                        <td>${mapping.source}</td>
                        <td>${mapping.originalName}
                            <button class="btn btn-sm btn-outline-secondary copy-to-pretty-btn"
                                    data-id="${mapping.id}" data-field="originalName" data-target="prettyName">
                                ↓
                            </button>
                        </td>
                        <td>${mapping.originalNetwork}
                            <button class="btn btn-sm btn-outline-secondary copy-to-pretty-btn"
                                    data-id="${mapping.id}" data-field="originalNetwork" data-target="prettyNetwork">
                                ↓
                            </button>
                        </td>
                        <td>
                            <input type="text" class="form-control network-input" value="${mapping.prettyNetwork}"
                                   data-id="${mapping.id}" data-field="prettyNetwork">
                        </td>
                        <td>
                            <input type="text" class="form-control name-input" value="${mapping.prettyName}"
                                   data-id="${mapping.id}" data-field="prettyName">
                        </td>
                        <td class="text-center">
                            <button class="btn btn-sm btn-outline-secondary copy-network-btn" data-id="${mapping.id}">
                                Copy Net
                            </button>
                            <button class="btn btn-sm btn-outline-secondary copy-campaign-btn" data-id="${mapping.id}">
                                Copy Camp
                            </button>
                        </td>
                    `;
                }

                elements.campaignTableBody.appendChild(row);
            });

            // Add event listeners to inputs
            document.querySelectorAll('.network-input, .name-input').forEach(input => {
                input.addEventListener('change', function() {
                    updateMapping(this.dataset.id, this.dataset.field, this.value);
                });

                input.addEventListener('focus', function() {
                    if (appState.selectedCell) {
                        appState.selectedCell.classList.remove('selected');
                    }
                    this.classList.add('selected');
                    appState.selectedCell = this;
                });

                input.addEventListener('blur', function() {
                    this.classList.remove('selected');
                    if (appState.selectedCell === this) {
                        appState.selectedCell = null;
                    }
                });
            });

            // Add event listeners to copy buttons
            document.querySelectorAll('.copy-network-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const mapping = appState.mappings.find(m => m.id === parseInt(this.dataset.id));
                    if (mapping) {
                        appState.copiedValue = mapping.prettyNetwork;
                        navigator.clipboard.writeText(mapping.prettyNetwork);
                        alert('Network name copied to clipboard!');
                    }
                });
            });

            document.querySelectorAll('.copy-campaign-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const mapping = appState.mappings.find(m => m.id === parseInt(this.dataset.id));
                    if (mapping) {
                        appState.copiedValue = mapping.prettyName;
                        navigator.clipboard.writeText(mapping.prettyName);
                        alert('Name copied to clipboard!');
                    }
                });
            });

            // Add event listeners to "Copy to Pretty" buttons
            document.querySelectorAll('.copy-to-pretty-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const id = parseInt(this.dataset.id);
                    const sourceField = this.dataset.field;
                    const targetField = this.dataset.target;
                    const mapping = appState.mappings.find(m => m.id === id);

                    if (mapping) {
                        // Copy the value from source field to target field
                        mapping[targetField] = mapping[sourceField];

                        // Update the input field
                        const input = document.querySelector(`input[data-id="${id}"][data-field="${targetField}"]`);
                        if (input) {
                            input.value = mapping[sourceField];
                        }

                        // Remove unmapped class if both fields are now filled
                        if (mapping.prettyNetwork && mapping.prettyName) {
                            const row = document.querySelector(`tr[data-id="${id}"]`);
                            if (row) {
                                row.classList.remove('unmapped');
                            }
                        }
                    }
                });
            });
        }

        // Update mapping
        function updateMapping(id, field, value) {
            const mapping = appState.mappings.find(m => m.id === parseInt(id));
            if (mapping) {
                mapping[field] = value;
            }
        }

        // Copy from original
        function copyFromOriginal(elements) {
            appState.mappings.forEach(mapping => {
                mapping.prettyNetwork = mapping.network;
                mapping.prettyCampaign = mapping.campaignName;
            });

            renderTable(elements);
        }

        // Capitalize networks
        function capitalizeNetworks(elements) {
            appState.mappings.forEach(mapping => {
                mapping.prettyNetwork = capitalizeString(mapping.prettyNetwork);
            });

            renderTable(elements);
        }

        // Capitalize names
        function capitalizeCampaigns(elements) {
            appState.mappings.forEach(mapping => {
                mapping.prettyName = capitalizeString(mapping.prettyName);
            });

            renderTable(elements);
        }

        // Add network prefix to names
        function addNetworkPrefix(elements) {
            appState.mappings.forEach(mapping => {
                if (mapping.prettyNetwork && mapping.prettyName) {
                    // Only add prefix if it doesn't already start with the network name
                    if (!mapping.prettyName.startsWith(mapping.prettyNetwork)) {
                        mapping.prettyName = `${mapping.prettyNetwork} - ${mapping.prettyName}`;
                    }
                }
            });

            renderTable(elements);
        }

        // Clear all mappings
        function clearAllMappings(elements) {
            if (confirm('Are you sure you want to clear all mappings?')) {
                appState.mappings.forEach(mapping => {
                    mapping.prettyNetwork = '';
                    mapping.prettyName = '';
                });

                renderTable(elements);
            }
        }

        // Helper function to capitalize string
        function capitalizeString(str) {
            if (!str) return str;
            return str.split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');
        }

        // Apply filters
        function applyFilters(elements) {
            renderTable(elements);
        }

        // Check if a mapping should be shown based on current filters
        function shouldShowMapping(mapping) {
            // Text filter
            if (appState.filters.text) {
                const searchText = appState.filters.text.toLowerCase();
                let textMatch = false;

                if (appState.dataFormat === 'redtrack' || appState.dataFormat === 'redtrack_new') {
                    textMatch =
                        (mapping.source || '').toLowerCase().includes(searchText) ||
                        (mapping.originalName || '').toLowerCase().includes(searchText) ||
                        (mapping.originalNetwork || '').toLowerCase().includes(searchText) ||
                        (mapping.prettyNetwork || '').toLowerCase().includes(searchText) ||
                        (mapping.prettyName || '').toLowerCase().includes(searchText) ||
                        (mapping.deviceType || '').toLowerCase().includes(searchText) ||
                        (mapping.utmCampaign || '').toLowerCase().includes(searchText) ||
                        (mapping.rtSource || '').toLowerCase().includes(searchText) ||
                        (mapping.rtCampaign || '').toLowerCase().includes(searchText) ||
                        (mapping.rtMedium || '').toLowerCase().includes(searchText);
                } else {
                    textMatch =
                        (mapping.source || '').toLowerCase().includes(searchText) ||
                        (mapping.originalName || '').toLowerCase().includes(searchText) ||
                        (mapping.originalNetwork || '').toLowerCase().includes(searchText) ||
                        (mapping.prettyNetwork || '').toLowerCase().includes(searchText) ||
                        (mapping.prettyName || '').toLowerCase().includes(searchText) ||
                        (mapping.refererName || '').toLowerCase().includes(searchText);
                }

                if (!textMatch) return false;
            }

            // Source type filter
            if (appState.filters.sourceType && mapping.source !== appState.filters.sourceType) {
                return false;
            }

            // Network filter
            if (appState.filters.network && mapping.originalNetwork.toLowerCase() !== appState.filters.network) {
                return false;
            }

            // Mapped only filter
            if (appState.filters.mappedOnly && (!mapping.prettyNetwork || !mapping.prettyName)) {
                return false;
            }

            return true;
        }

        // Initialize ordering
        function initializeOrdering() {
            // Get unique networks
            const networks = new Set();
            const namesByNetwork = {};

            appState.mappings.forEach(mapping => {
                if (mapping.prettyNetwork) {
                    networks.add(mapping.prettyNetwork);

                    if (!namesByNetwork[mapping.prettyNetwork]) {
                        namesByNetwork[mapping.prettyNetwork] = new Set();
                    }

                    if (mapping.prettyName) {
                        namesByNetwork[mapping.prettyNetwork].add(mapping.prettyName);
                    }
                }
            });

            // Initialize ordering state
            appState.ordering.networks = Array.from(networks);
            appState.ordering.namesByNetwork = {};

            Object.keys(namesByNetwork).forEach(network => {
                appState.ordering.namesByNetwork[network] = Array.from(namesByNetwork[network]);
            });
        }

        // Render order lists
        function renderOrderLists(elements) {
            // Render network order list
            renderNetworkOrderList(elements);

            // Populate order network select
            populateOrderNetworkSelect(elements);

            // Render name order list for selected network
            renderNameOrderList(elements);
        }

        // Render network order list
        function renderNetworkOrderList(elements) {
            elements.networkOrderList.innerHTML = '';

            appState.ordering.networks.forEach((network, index) => {
                const item = document.createElement('div');
                item.className = 'list-group-item d-flex justify-content-between align-items-center';
                item.dataset.network = network;
                item.innerHTML = `
                    <div>
                        <span class="drag-handle me-2">&#9776;</span>
                        <span>${index + 1}. ${network}</span>
                    </div>
                `;

                elements.networkOrderList.appendChild(item);
            });

            // Initialize sortable for network order list
            new Sortable(elements.networkOrderList, {
                animation: 150,
                handle: '.drag-handle',
                onEnd: function() {
                    // Update network order in UI only (will be saved on Update button click)
                }
            });
        }

        // Populate order network select
        function populateOrderNetworkSelect(elements) {
            // Save current selection
            const currentValue = elements.orderNetworkSelect.value;

            // Clear options except the first one
            while (elements.orderNetworkSelect.options.length > 1) {
                elements.orderNetworkSelect.remove(1);
            }

            // Add options for each network
            appState.ordering.networks.forEach(network => {
                const option = document.createElement('option');
                option.value = network;
                option.textContent = network;
                elements.orderNetworkSelect.appendChild(option);
            });

            // Restore selection if possible
            if (currentValue && Array.from(elements.orderNetworkSelect.options).some(opt => opt.value === currentValue)) {
                elements.orderNetworkSelect.value = currentValue;
            } else if (elements.orderNetworkSelect.options.length > 1) {
                elements.orderNetworkSelect.selectedIndex = 1; // Select first network
            }
        }

        // Render name order list
        function renderNameOrderList(elements) {
            elements.nameOrderList.innerHTML = '';

            const selectedNetwork = elements.orderNetworkSelect.value;
            if (!selectedNetwork || !appState.ordering.namesByNetwork[selectedNetwork]) {
                return;
            }

            appState.ordering.namesByNetwork[selectedNetwork].forEach((name, index) => {
                const item = document.createElement('div');
                item.className = 'list-group-item d-flex justify-content-between align-items-center';
                item.dataset.name = name;
                item.innerHTML = `
                    <div>
                        <span class="drag-handle me-2">&#9776;</span>
                        <span>${index + 1}. ${name}</span>
                    </div>
                `;

                elements.nameOrderList.appendChild(item);
            });

            // Initialize sortable for name order list
            new Sortable(elements.nameOrderList, {
                animation: 150,
                handle: '.drag-handle',
                onEnd: function() {
                    // Update name order in UI only (will be saved on Update button click)
                }
            });
        }

        // Update order from UI
        function updateOrderFromUI(elements) {
            // Update network order
            const networkItems = elements.networkOrderList.querySelectorAll('.list-group-item');
            appState.ordering.networks = Array.from(networkItems).map(item => item.dataset.network);

            // Update name order for selected network
            const selectedNetwork = elements.orderNetworkSelect.value;
            if (selectedNetwork) {
                const nameItems = elements.nameOrderList.querySelectorAll('.list-group-item');
                appState.ordering.namesByNetwork[selectedNetwork] = Array.from(nameItems).map(item => item.dataset.name);
            }
        }

        // Reset order
        function resetOrder(elements) {
            initializeOrdering();
        }

        // Apply rules to mappings
        function applyRulesToMappings(elements) {
            // Apply rules to all mappings
            appState.mappings = RuleEngine.applyRules(appState.mappings);

            // Re-render the table
            renderTable(elements);

            // Update ordering
            initializeOrdering();
            renderOrderLists(elements);
        }

        // Render rules list
        function renderRulesList(elements) {
            elements.rulesList.innerHTML = '';

            // Get rule names
            const ruleNames = RuleEngine.getRuleNames();

            // Create a list item for each rule
            ruleNames.forEach(ruleName => {
                const item = document.createElement('div');
                item.className = 'list-group-item d-flex justify-content-between align-items-center';
                item.innerHTML = `
                    <div>
                        <span>${ruleName}</span>
                    </div>
                    <div>
                        <div class="form-check form-switch">
                            <input class="form-check-input rule-toggle" type="checkbox"
                                   id="rule-${ruleName.replace(/\s+/g, '-').toLowerCase()}"
                                   data-rule="${ruleName}" checked>
                        </div>
                    </div>
                `;

                elements.rulesList.appendChild(item);
            });

            // Add event listeners to rule toggles
            document.querySelectorAll('.rule-toggle').forEach(toggle => {
                toggle.addEventListener('change', function() {
                    const ruleName = this.dataset.rule;
                    RuleEngine.toggleRule(ruleName, this.checked);
                });
            });
        }

        // Save rules to file
        function saveRulesToFile() {
            const rulesJson = RuleEngine.exportRules();
            const blob = new Blob([rulesJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            // Create a temporary link and click it
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sqlmapper-rules.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Save mappings to file
        function saveMappingsToFile() {
            const data = {
                mappings: appState.mappings,
                ordering: appState.ordering
            };

            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            // Create a temporary link and click it
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sqlmapper-mappings.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Load mappings from file
        function loadMappingsFromFile(file, elements) {
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    if (data.mappings && Array.isArray(data.mappings)) {
                        appState.mappings = data.mappings;
                    }

                    if (data.ordering) {
                        appState.ordering = data.ordering;
                    } else {
                        // If no ordering in the file, initialize it
                        initializeOrdering();
                    }

                    // Render everything
                    renderTable(elements);
                    renderOrderLists(elements);

                    alert('Mappings loaded successfully!');
                } catch (error) {
                    alert('Error loading mappings: ' + error.message);
                }
            };

            reader.readAsText(file);
        }

        // Generate SQL query
        function generateSql(elements) {
            // Start building the SQL query with BigQuery style
            let sql = `WITH RawTraffic AS (\n`;
            sql += `  SELECT\n`;
            sql += `    idvisit,\n`;
            sql += `    idvisitor,\n`;
            sql += `    visitor_returning,\n`;
            sql += `    config_device_type,\n`;
            sql += `    referer_type,\n`;
            sql += `    referer_name,\n`;
            sql += `    campaign_name,\n`;
            sql += `    campaign_source,\n`;
            sql += `    visit_total_actions,\n`;
            sql += `    visit_total_time\n`;
            // Get the table name from the input field
            const tableName = elements.tableNameInput.value.trim() || 'matomotransfers.matomo_export.log_visit';
            sql += `  FROM \`${tableName}\`\n`;
            sql += `  WHERE visit_first_action_time >= '2025-01-01'\n`;
            sql += `    AND visit_first_action_time < '2025-02-01'\n`;
            sql += `),\n`;

            if (appState.dataFormat === 'redtrack') {
                // RedTrack format
                sql += `DeducedTraffic AS (\n`;
                sql += `  SELECT\n`;
                sql += `    id AS idvisit,\n`; // Use appropriate ID field
                sql += `    visitor_id AS idvisitor,\n`; // Use appropriate visitor ID field
                sql += `    0 AS visitor_returning,\n`; // Default value
                sql += `    device_type AS config_device_type,\n`;
                sql += `    deduced_source,\n`;
                sql += `    campaign_name,\n`;
                sql += `    utm_campaign,\n`;
                sql += `    utm_source,\n`;
                sql += `    device_type,\n`;
                sql += `    1 AS visit_total_actions,\n`; // Default value
                sql += `    0 AS visit_total_time\n`; // Default value
                sql += `  FROM RawTraffic\n`;
                sql += `),\n`;
            } else {
                // Matomo format
                sql += `DeducedTraffic AS (\n`;
                sql += `  SELECT\n`;
                sql += `    idvisit,\n`;
                sql += `    idvisitor,\n`;
                sql += `    visitor_returning,\n`;
                sql += `    CAST(config_device_type AS STRING) AS config_device_type,\n`;
                sql += `    CAST(CASE\n`;
                sql += `      WHEN referer_type = 1 THEN 'Direct'\n`;
                sql += `      WHEN referer_type = 2 THEN 'Search Engine'\n`;
                sql += `      WHEN referer_type = 3 THEN 'Website'\n`;
                sql += `      WHEN referer_type = 6 THEN 'Campaign'\n`;
                sql += `      WHEN referer_type = 7 THEN 'Social Network'\n`;
                sql += `      ELSE 'Unknown'\n`;
                sql += `    END AS STRING) AS deduced_source,\n`;
                sql += `    campaign_name,\n`;
                sql += `    campaign_source,\n`;
                sql += `    referer_name,\n`;
                sql += `    visit_total_actions,\n`;
                sql += `    visit_total_time\n`;
                sql += `  FROM RawTraffic\n`;
                sql += `),\n`;
            }

            // Create MappingDictionary with the user's mappings
            sql += `MappingDictionary AS (\n`;
            sql += `  SELECT * FROM UNNEST([\n`;

            // Create mapping entries from the user's mappings
            const mappingEntries = [];

            // Track outer_col and inner_col for each network and name
            let networkCounter = {};
            let nameCounter = {};

            // First, assign outer_col (network order)
            // Make sure we have a valid ordering array
            if (appState.ordering.networks && appState.ordering.networks.length > 0) {
                appState.ordering.networks.forEach((prettyNetwork, index) => {
                    if (prettyNetwork) {
                        networkCounter[prettyNetwork] = index + 1; // 1-based index for outer_col
                        nameCounter[prettyNetwork] = {};
                    }
                });
            } else {
                // If no ordering is defined, create a default ordering based on the mappings
                const uniqueNetworks = new Set();
                appState.mappings.forEach(mapping => {
                    if (mapping.prettyNetwork) {
                        uniqueNetworks.add(mapping.prettyNetwork);
                    }
                });

                Array.from(uniqueNetworks).sort().forEach((network, index) => {
                    networkCounter[network] = index + 1;
                    nameCounter[network] = {};
                });
            }

            // Then, assign inner_col (name order within each network)
            if (appState.ordering.namesByNetwork && Object.keys(appState.ordering.namesByNetwork).length > 0) {
                Object.entries(appState.ordering.namesByNetwork).forEach(([prettyNetwork, prettyNames]) => {
                    if (prettyNames && prettyNames.length > 0) {
                        prettyNames.forEach((prettyName, nameIndex) => {
                            if (nameCounter[prettyNetwork] && prettyName) {
                                nameCounter[prettyNetwork][prettyName] = nameIndex + 1; // 1-based index for inner_col
                            }
                        });
                    }
                });
            } else {
                // If no name ordering is defined, create a default ordering based on the mappings
                const namesByNetwork = {};

                appState.mappings.forEach(mapping => {
                    if (mapping.prettyNetwork && mapping.prettyName) {
                        if (!namesByNetwork[mapping.prettyNetwork]) {
                            namesByNetwork[mapping.prettyNetwork] = new Set();
                        }
                        namesByNetwork[mapping.prettyNetwork].add(mapping.prettyName);
                    }
                });

                Object.entries(namesByNetwork).forEach(([network, names]) => {
                    Array.from(names).sort().forEach((name, index) => {
                        if (!nameCounter[network]) {
                            nameCounter[network] = {};
                        }
                        nameCounter[network][name] = index + 1;
                    });
                });
            }

            // Create mapping entries
            appState.mappings.forEach(mapping => {
                if (mapping.prettyNetwork && mapping.prettyName) {
                    const outer_col = networkCounter[mapping.prettyNetwork] || 999;
                    const inner_col = nameCounter[mapping.prettyNetwork]?.[mapping.prettyName] || 999;

                    if (appState.dataFormat === 'redtrack') {
                        // RedTrack format
                        mappingEntries.push(
                            `    STRUCT('${mapping.source}' AS deduced_source, ` +
                            `${mapping.originalName ? `'${mapping.originalName}'` : 'NULL'} AS campaign_name, ` +
                            `${mapping.utmCampaign ? `'${mapping.utmCampaign}'` : 'NULL'} AS utm_campaign, ` +
                            `${mapping.originalNetwork ? `'${mapping.originalNetwork}'` : 'NULL'} AS utm_source, ` +
                            `${mapping.deviceType ? `'${mapping.deviceType}'` : 'NULL'} AS device_type, ` +
                            `'${mapping.prettyName}' AS pretty_name, ` +
                            `'${mapping.prettyNetwork}' AS pretty_network, ` +
                            `${outer_col} AS outer_col, ${inner_col} AS inner_col)`
                        );
                    } else {
                        // Matomo format
                        mappingEntries.push(
                            `    STRUCT('${mapping.source}' AS deduced_source, ` +
                            `${mapping.originalName ? `'${mapping.originalName}'` : 'NULL'} AS campaign_name, ` +
                            `${mapping.originalNetwork ? `'${mapping.originalNetwork}'` : 'NULL'} AS campaign_source, ` +
                            `${mapping.refererName ? `'${mapping.refererName}'` : 'NULL'} AS referer_name, ` +
                            `'${mapping.prettyName}' AS pretty_name, ` +
                            `'${mapping.prettyNetwork}' AS pretty_network, ` +
                            `${outer_col} AS outer_col, ${inner_col} AS inner_col)`
                        );
                    }
                }
            });

            // Add mapping entries to the SQL
            if (mappingEntries.length === 0) {
                // Add a dummy entry if no mappings exist
                sql += `    STRUCT('Campaign' AS deduced_source, NULL AS campaign_name, NULL AS campaign_source, NULL AS referer_name, 'No Mappings' AS pretty_name, 'Unknown' AS pretty_network, 999 AS outer_col, 999 AS inner_col)\n`;
            } else {
                sql += mappingEntries.join(',\n') + '\n';
            }

            sql += `  ])\n`;
            sql += `),\n`;

            // Continue with the rest of the query
            if (appState.dataFormat === 'redtrack') {
                // RedTrack format
                sql += `Joined AS (\n`;
                sql += `  SELECT\n`;
                sql += `    D.idvisit,\n`;
                sql += `    D.idvisitor,\n`;
                sql += `    D.visitor_returning,\n`;
                sql += `    D.config_device_type,\n`;
                sql += `    COALESCE(M.pretty_name, D.campaign_name, D.deduced_source) AS pretty_name,\n`;
                sql += `    COALESCE(M.pretty_network, 'Unknown') AS pretty_network,\n`;
                sql += `    COALESCE(M.outer_col, 9999) AS outer_col,\n`;
                sql += `    COALESCE(M.inner_col, 9999) AS inner_col,\n`;
                sql += `    D.visit_total_actions,\n`;
                sql += `    D.visit_total_time\n`;
                sql += `  FROM DeducedTraffic D\n`;
                sql += `  LEFT JOIN MappingDictionary M\n`;
                sql += `    ON D.deduced_source = M.deduced_source\n`;
                sql += `    AND COALESCE(NULLIF(D.campaign_name, ''), '<empty>') = COALESCE(NULLIF(M.campaign_name, ''), '<empty>')\n`;
                sql += `    AND COALESCE(NULLIF(D.utm_campaign, ''), '<empty>') = COALESCE(NULLIF(M.utm_campaign, ''), '<empty>')\n`;
                sql += `    AND COALESCE(NULLIF(D.utm_source, ''), '<empty>') = COALESCE(NULLIF(M.utm_source, ''), '<empty>')\n`;
                sql += `    AND COALESCE(NULLIF(D.device_type, ''), '<empty>') = COALESCE(NULLIF(M.device_type, ''), '<empty>')\n`;
                sql += `),\n`;
            } else {
                // Matomo format
                sql += `Joined AS (\n`;
                sql += `  SELECT\n`;
                sql += `    D.idvisit,\n`;
                sql += `    D.idvisitor,\n`;
                sql += `    D.visitor_returning,\n`;
                sql += `    D.config_device_type,\n`;
                sql += `    COALESCE(M.pretty_name, D.campaign_name, D.referer_name, D.deduced_source) AS pretty_name,\n`;
                sql += `    COALESCE(M.pretty_network, 'Unknown') AS pretty_network,\n`;
                sql += `    COALESCE(M.outer_col, 9999) AS outer_col,\n`;
                sql += `    COALESCE(M.inner_col, 9999) AS inner_col,\n`;
                sql += `    D.visit_total_actions,\n`;
                sql += `    D.visit_total_time\n`;
                sql += `  FROM DeducedTraffic D\n`;
                sql += `  LEFT JOIN MappingDictionary M\n`;
                sql += `    ON D.deduced_source = M.deduced_source\n`;
                sql += `    AND COALESCE(NULLIF(D.campaign_name, ''), '<empty>') = COALESCE(NULLIF(M.campaign_name, ''), '<empty>')\n`;
                sql += `    AND COALESCE(NULLIF(D.campaign_source, ''), '<empty>') = COALESCE(NULLIF(M.campaign_source, ''), '<empty>')\n`;
                sql += `    AND COALESCE(NULLIF(D.referer_name, ''), '<empty>') = COALESCE(NULLIF(M.referer_name, ''), '<empty>')\n`;
                sql += `),\n`;
            }

            sql += `Aggregated AS (\n`;
            sql += `  SELECT\n`;
            sql += `    pretty_name,\n`;
            sql += `    pretty_network,\n`;
            sql += `    outer_col,\n`;
            sql += `    inner_col,\n`;
            sql += `    COUNT(DISTINCT idvisit) AS visit_count,\n`;
            sql += `    COUNT(DISTINCT idvisitor) AS unique_visitors,\n`;
            sql += `    AVG(visit_total_actions) AS avg_actions,\n`;
            sql += `    AVG(visit_total_time) AS avg_time\n`;
            sql += `  FROM Joined\n`;
            sql += `  GROUP BY pretty_name, pretty_network, outer_col, inner_col\n`;
            sql += `)\n`;

            // Final query
            sql += `SELECT\n`;
            sql += `  pretty_name,\n`;
            sql += `  pretty_network,\n`;
            sql += `  outer_col,\n`; // Include ordering columns in output
            sql += `  inner_col,\n`;
            sql += `  visit_count,\n`;
            sql += `  unique_visitors,\n`;
            sql += `  ROUND(avg_actions, 2) AS avg_actions_per_visit,\n`;
            sql += `  ROUND(avg_time / 60, 2) AS avg_duration_minutes\n`;
            sql += `FROM Aggregated\n`;
            sql += `ORDER BY outer_col, inner_col`; // This ensures results are ordered by network and campaign order

            // Set SQL output
            elements.sqlOutput.value = sql;
        }

        // Copy SQL to clipboard
        function copySqlToClipboard(elements) {
            navigator.clipboard.writeText(elements.sqlOutput.value).then(() => {
                alert('SQL copied to clipboard!');
            });
        }
    </script>
</body>
</html>
